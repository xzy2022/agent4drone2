# Multi-Agent Architecture Refactor - A/B Pipeline

## Overview

The multi-agent system has been successfully refactored to use an A/B Pipeline architecture:

- **Agent A (Planner)**: Responsible for conversation, intent parsing, and generating tool execution plans
- **Node B (Tools)**: Responsible for validating, fixing, and executing plans (stateless)

## Architecture

### Pipeline Flow

```
User Input
    ↓
[Agent A: Planner] → Generates JSON Plan
    ↓
[Node B: Tools] → Validates & Fixes Plan
    ↓
[Node B: Tools] → Executes Plan
    ↓
[Coordinator] → Aggregates Results
    ↓
Final Output to User
```

### Key Design Principles

1. **Agent A (Planner)**:
   - Conversational and strategic
   - Maintains context across interactions
   - Does NOT execute tools directly
   - Outputs structured JSON plans

2. **Node B (Tools)**:
   - Tactical and stateless
   - No memory between executions
   - Validates, fixes, and executes plans
   - Returns execution results

## New Files Created

### 1. `plan_schema.py`
Defines data structures for the pipeline:

- `Plan`: Complete execution plan
- `PlanStep`: Single step in the plan
- `ExecutionResult`: Result from executing a step
- `ExecutionReport`: Complete execution report
- `ValidationFix`: Fix applied during validation
- `ValidatedPlan`: Plan after validation

### 2. `planner_agent.py`
Agent A implementation:

```python
class PlannerAgent:
    def plan(user_input: str) -> Plan:
        """Generate execution plan from user input"""
```

### 3. `tools_node.py`
Node B implementation:

```python
class ToolsNode:
    def validate_and_fix(plan: Plan) -> ValidatedPlan:
        """Validate and fix the plan"""

    def execute(validated_plan: ValidatedPlan) -> ExecutionReport:
        """Execute the validated plan"""
```

### 4. `coordinator.py` (Refactored)
A/B Pipeline orchestrator:

```python
class MultiAgentCoordinator:
    def execute(user_input: str) -> Dict[str, Any]:
        """Execute command using A/B pipeline"""
```

## Usage

### Basic Usage

```python
from src.agents.multi import MultiAgentCoordinator
from src.api_client import UAVAPIClient

# Create client
client = UAVAPIClient(base_url="http://localhost:8000")

# Initialize coordinator
coordinator = MultiAgentCoordinator(
    client=client,
    llm_provider="ollama",
    llm_model="qwen3:1.7b",
    verbose=True,
    debug=False
)

# Execute command
result = coordinator.execute("Take photos at all target locations")

# Check result
if result['success']:
    print(result['output'])
else:
    print(f"Error: {result['output']}")
```

### Accessing Pipeline Details

```python
result = coordinator.execute("Move drone to position (100, 50, 20)")

# Access the plan generated by Agent A
plan = result['plan']
print(f"Plan: {plan['rationale']}")
print(f"Steps: {len(plan['steps'])}")

# Access validation from Node B
validation = result['validation']
print(f"Fixes applied: {len(validation['fixes'])}")

# Access execution results
execution = result['execution']
print(f"Status: {execution['final_status']}")
print(f"Summary: {execution['summary']}")
```

### Session Management

```python
# Refresh session context
coordinator.refresh_session_context()

# Get session summary
summary = coordinator.get_session_summary()
print(summary)

# Get execution history
history = coordinator.get_execution_history()
print(f"Executions: {len(history)}")
```

## Plan JSON Format

Agent A generates plans in this JSON format:

```json
{
  "user_intent": "Capture photos at all target locations",
  "rationale": "First get targets, then visit each with drone",
  "steps": [
    {
      "step_id": "step_1",
      "tool_name": "get_session_info",
      "args": {},
      "rationale": "Get current session and targets",
      "expected_effect": "Returns session data",
      "dependencies": []
    },
    {
      "step_id": "step_2",
      "tool_name": "list_drones",
      "args": {},
      "rationale": "Get available drones",
      "expected_effect": "Returns drone list",
      "dependencies": []
    },
    {
      "step_id": "step_3",
      "tool_name": "take_off",
      "args": {"drone_id": "drone-001", "altitude": 20},
      "rationale": "Take drone to mission altitude",
      "expected_effect": "Drone airborne",
      "dependencies": ["step_2"]
    }
  ]
}
```

## Validation & Fixes

Node B performs three types of validation:

### 1. Tool Executability
- Checks if all tools exist
- Suggests alternatives for missing tools
- Skips steps with no valid tool

### 2. Parameter Validity
- Validates parameter types
- Resolves references (e.g., `$drone_id` → actual ID)
- Ensures required parameters are present

### 3. Physical Meaning
- Checks altitude ranges (0-500m)
- Validates coordinates (reasonable bounds)
- Checks speed limits (safe values)

## Testing

Run the test script to verify the installation:

```bash
python test_multi_agent.py
```

Expected output:
```
************************************************************
* Multi-Agent Architecture Test (A/B Pipeline)
**************************************************************

============================================================
Testing Plan Schema...
============================================================
Plan ID: <uuid>
Intent: Test taking photos at targets
Steps: 2
Plan created successfully!

PASS: Plan schema test

============================================================
Testing MultiAgentCoordinator Initialization...
============================================================
[OK] Multi-Agent Coordinator (A/B Pipeline) initialized
   Planner (Agent A): qwen3:1.7b
   Tools Node (Node B): Stateless executor

PASS: Coordinator initialization test

============================================================
Test Summary
============================================================
New Multi-Agent Architecture (A/B Pipeline) is ready!
```

## Integration with Existing Code

The new architecture maintains backward compatibility with existing code:

```python
# Legacy specialized agents still available
from src.agents.multi import (
    NavigatorAgent,
    ReconnaissanceAgent,
    SafetyMonitorAgent
)
```

## Configuration

Supported LLM providers:

1. **Ollama** (default):
   ```python
   coordinator = MultiAgentCoordinator(
       client=client,
       llm_provider="ollama",
       llm_model="qwen3:1.7b"  # or "qwen3:8b"
   )
   ```

2. **OpenAI**:
   ```python
   coordinator = MultiAgentCoordinator(
       client=client,
       llm_provider="openai",
       llm_model="gpt-4o-mini",
       llm_api_key="your-api-key"
   )
   ```

3. **OpenAI-Compatible**:
   ```python
   coordinator = MultiAgentCoordinator(
       client=client,
       llm_provider="openai-compatible",
       llm_model="your-model",
       llm_api_key="your-api-key",
       llm_base_url="https://your-endpoint.com/v1"
   )
   ```

## File Structure

```
src/agents/multi/
├── __init__.py              # Module exports
├── plan_schema.py           # Data structures (NEW)
├── planner_agent.py         # Agent A implementation (NEW)
├── tools_node.py            # Node B implementation (NEW)
├── coordinator.py           # A/B Pipeline orchestrator (REFACTORED)
└── specialized_agents.py    # Legacy agents (BACKWARD COMPAT)
```

## Benefits of A/B Architecture

1. **Separation of Concerns**: Planning vs. execution
2. **Better Validation**: Plans validated before execution
3. **Stateless Execution**: Node B has no memory, fresh each time
4. **Easier Debugging**: Clear pipeline stages
5. **Flexible**: Can swap out Agent A or Node B independently
6. **Observable**: Each phase produces structured output

## Next Steps

To use this in your application:

1. Import the coordinator
2. Initialize with your preferred LLM
3. Execute commands using the pipeline
4. Access detailed results from each phase

For GUI integration (main_new.py), you can replace the single agent with the multi-agent coordinator for more sophisticated planning and execution.
